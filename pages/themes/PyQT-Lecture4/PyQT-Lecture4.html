<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>PyQt-Lecture4</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="shortcut icon" type="image/jpg" href="/PythonCourseNetIT-Slides/favicon.png"/>

    <!-- css & themes include -->
    <link rel="stylesheet" href="/PythonCourseNetIT-Slides/lib/reveal.js/css/reveal.css">
    <link rel="stylesheet" href="/PythonCourseNetIT-Slides/outfit/css/themes/light.css" id="theme">
    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? '/PythonCourseNetIT-Slides/outfit/css/print.css' : '/PythonCourseNetIT-Slides/lib/reveal.js/css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
    <!-- CUSTOM -->
    <base target="_blank">
</head>
<body>
    <div class="reveal default center" data-transition-speed="default" data-background-transition="default">
        <div class="top_links">
            <a class="home_link" href="/PythonCourseNetIT-Slides/pages/agenda/agenda.html#DB-Lecture2" target="_top"></a>
            <span class="help_link"><i class="fa fa-question"></i></span>
            <div class="help_text">
                <div class="note">Keyboard shortcuts:</div>
                <div><span>N/Спейс</span><span>Next Slide</span></div>
                <div><span>P</span><span>Previous Slide</span></div>
                <div><span>O</span><span>Slides Overview</span></div>
                <div><span>ctrl+left click</span><span>Zoom Element</span></div>
                <div class="print-howto"><br>If you want print version => add '<code>?print-pdf</code>' <br> at the end of slides URL (remove '#' fragment) and then print. <br>
                Like: https://wwwcourses.github.io/...CourseIntro.html?print-pdf </div>
            </div>
        </div>
        <div class="footer theme_switch">
            <a href="#" onclick="document.getElementById('theme').setAttribute('href','/PythonCourseNetIT-Slides/outfit/css/themes/dark.css'); return false;">Dark</a>
            <a href="#" onclick="document.getElementById('theme').setAttribute('href','/PythonCourseNetIT-Slides/outfit/css/themes/light.css'); return false;">Light</a>
            <a href="#" onclick="document.getElementById('theme').setAttribute('href','/PythonCourseNetIT-Slides/outfit/css/themes/projector.css'); return false;">Projector</a>
        </div>
        <div class="slides">
<!--
########################################################
##################### SLIDES START #####################
########################################################
-->
<section class="main-section-title"><h1>PyQt - Lecture 4</h1></section>
<section data-transition="zoom">
    <section class="copyright" data-transition="zoom">
        <div class="note">
            <p>Created for</p>
        </div>
        <div class="company">
            <a href="https://softwareacademy.bg/">
            <img style="height:80%" src="/PythonCourseNetIT-Slides/outfit/images/logos/software-web@4x.png" alt="software-web@4x.png">
            </a>
        </div>
        <div class="author">
            <span class="note"><a href="https://www.linkedin.com/in/ivapopova/">Iva E. Popova</a>, 2022-2023,</span>
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
            <!-- <i class="fa fa-linkedin"></i> -->
        </div>
    </section>
</section>


<section data-min="5" class="main-section-title" id="IntroductionToSignalsAndSlots"><h1>Introduction to Signals And Slots</h1></section>
<section class="sub-sections"><h2>Signals And Slots Overview</h2>
    <section><h3>What are Signals And Slots?</h3>
        <a href="./images/signals_and_slots.png"><img src="./images/signals_and_slots.png" alt="signals_and_slots.png" style="min-height: 80vh;"></a>
        <dl class="fa">
            <!-- <dt>Qt library provides two parallel mechanisms to define and process events.</dt>
            <ol>
                <li>Using <code>QEvent</code> class - which is appropriate for implementing custom widgets</li>
                <li><code>Signals</code> when we just using widgets already defined in QWidget hierarchy.</li>
            </ol> -->
            <dt>Signals and slots are used for communication between objects.</dt>
            <dt>For example, if a user clicks a Close button, we probably want the window's close() function to be called.</dt>
            <dt>A signal is s notification that the event has happened</dt>
            <dt>A slot is a function that is called, when that event occurs.</dt>
            <dt>In order to establish communication between objects, we <span class="note">connect</span> a signal to a slot to achieve the desired action</dt>
        </dl>
    </section>
    <section><h3>What are Signals And Slots?</h3>
        <dl class="fa">
            <dt>A <span class="note">Signal is a special object property</span> that can be emitted in response to a event.</dt>
            <dt>Usually, we emit signals when the object's internal state has changed.</dt>
            <dt>A <span class="note">Slot is an object method</span> that can receive a signal and act in response to it.</dt>
            <dt>In fact, a slot can be not only a Qt object method, <span class="note">it can be any Python callable</span>.</dt>
            <dt>When a signal is emitted, the slots connected to it are usually executed immediately</dt>
        </dl>
    </section>
    <section><h3>Signals and Slots Example</h3>
        <dl class="fa">
            <dt>A QPushButton has a <a href="https://doc.qt.io/qt-6/qabstractbutton.html#clicked">clicked signal</a> that is emitted whenever the button is clicked by a user. </dt>
            <dt>The QWidget class has a <a href="https://doc.qt.io/qt-6/qwidget.html#close">close() slot</a> that causes it to close if it's a top-level window. </dt>
            <dt>We could connect the two like this:</dt>
        </dl>
        <pre><code rel="Python" class="python">
            self.btn_cancel = qtw.QPushButton('Cancel')
            self.btn_cancel.clicked.connect(self.close)
        </code></pre>
        <dt>All classes descended from QObject (including all QWidget classes) can send and receive signals.</dt>
    </section>
    <section><h3>Different combinations of signals and slots</h3>
        <dl class="fa">
            <dt>One signal can be connected to one or many slots</dt>
            <dd>If a signal is connected to several slots they will be executed one after the other, in the order they have been connected, when the signal is emitted.</dd>
            <dt>Many signals can be connected to the same slot</dt>
            <dt>A signal can be connected to other signals</dt>
            <dt>Connections can be removed</dt>
        </dl>
    </section>
    <section><h3>Common predefined Signals and Slots</h3>
        <dl class="fa">
            <dt>All buttons have next signals and slots: <a href="https://doc.qt.io/qt-5/qabstractbutton.html#public-slots">QAbstractButton Slots and Signals</a></dt>
            <dt>QLineEdit object has: <a href="https://doc.qt.io/qt-5/qlineedit.html#public-slots">QLineEdit Slots And Signals</a></dt>
            <dt>All QWidget objects have next <a href="https://doc.qt.io/qt-5/qwidget.html#public-slots">QWidget Slots</a> and <a href="https://doc.qt.io/qt-5/qwidget.html#signals">QWidget Signals</a></dt>
        </dl>
    </section>
</section>

<section data-min="50" class="main-section-title" id="PassingDataBetweenSignalsAndSlots"><h1>Passing data between signals and slots</h1></section>
<section class="sub-sections"><h2>Passing data between signals and slots</h2>
    <section>
        <dl class="fa">
            <dt>Signals can also pass data to the slots they are connected.</dt>
            <dt>For example, QLineEdit object has a <code>textChanged</code> signal that sends the text entered into the widget along with the signal</dt>
            <dt>The QLineEdit object also has a <code>setText()</code> slot that accepts a string argument. We could connect them like this:</dt>
            <pre><code rel="Python" class="python">
                self.line_edit1 = qtw.QLineEdit()
                self.line_edit2 = qtw.QLineEdit()

                self.line_edit1.textChanged.connect(self.line_edit2.setText)

                self.mainLayout = qtw.QVBoxLayout()
                self.mainLayout.addWidget(self.line_edit1)
                self.mainLayout.addWidget(self.line_edit2)

                self.setLayout(self.mainLayout)
            </code></pre>
        </dl>
    </section>
    <section><h3>Task: Print in console the text in a lineEdit</h3>
        <dl class="fa">
            <dt>Create a Widget with  1 QLineEdit object  (<code>line_edit1</code>) in it</dt>
            <dt>We want on every change to the content of <code>line_edit1</code> that content to be printed in the console.</dt>
        </dl>
    </section>
    <section><h3>Solution</h3>
        <pre><code rel="Python" class="python" style="min-height: 1vh;">
            import sys
            from PyQt6 import QtWidgets as qtw

            class MainWindow(qtw.QWidget):
                def __init__(self, *args, **kwargs):
                    super().__init__(*args, **kwargs)

                    # Set up the main layout
                    main_layout = qtw.QVBoxLayout(self)

                    # Create and add the QLineEdit to the layout
                    self.leTest = qtw.QLineEdit()
                    main_layout.addWidget(self.leTest)

                    # Connect the textChanged signal to the custom slot
                    self.leTest.textChanged.connect(self.print_content)

                    self.setWindowTitle('Demo')
                    self.show()

                def print_content(self, text):
                    print(f'Content: {text}')

            # Run the application
            if __name__ == '__main__':
                app = qtw.QApplication(sys.argv)
                window = MainWindow()
                sys.exit(app.exec())

        </code></pre>
    </section>
    <section>
        <dl class="fa">
            <dt>Signals can even be connected to other signals, for example:</dt>
            <pre><code rel="Python" class="python">
                self.line_edit1.editingFinished.connect(lambda: print('Edit Done'))
                self.line_edit2.returnPressed.connect(self.line_edit1.editingFinished)
            </code></pre>
            <dt>When you connect a signal to another signal, the event and data are passed from one signal to the next</dt>
        </dl>
    </section>
</section>


<section data-min="5" class="main-section-title" id="CustomSignalsAndSlots"><h1>Custom signals and slots</h1></section>
<section class="sub-sections"><h2>Custom slots</h2>
    <section><h3>Custom Slots</h3>
        <dl class="fa">
            <dt>Any Python callable can play the role of a slot.</dt>
            <dt>Custom slots are called when a signal is emitted. </dt>
        </dl>
        <pre><code rel="Python" class="python">
            self.line_edit.textChanged.connect(self.some_slot)

            def some_slot(signal, text, x):
                print(text, x)

            # TypeError: some_slot() missing 1 required positional argument: 'x'
        </code></pre>
    </section>
    <section><h3 class="advanced">Type-safety using slots decorators</h3>
        <dl class="fa">
            <dt>QtCore contains a pyqtSlot() function, which we can use to decorate a Python callable as a slot.</dt>
            <dt>pyqtSlot() is a decorator that takes a Python callable and returns a slot object. </dt>
            <dt>The slot object is a wrapper around the Python callable that can be connected to a signal. </dt>
            <dt>Using the pyqtSlot() decorator allows us to specify the type of the arguments that will be passed to the slot.</dt>
        </dl>
        <pre><code rel="Python" class="python">
            @qtc.pyqtSlot(str)
            def some_slot(*args):
                for arg in args:
                    print(arg)
        </code></pre>
    </section>
</section>
<section class="sub-sections"><h2>Custom Signals</h2>
    <section id="DefiningCustomSignals"><h3>Defining Custom Signals</h3>
        <dl class="fa">
            <dt>Custom signals are defined using the <code>pyqtSignal()</code> function.</dt>
            <dt>pyqtSignal() returns a signal object, which is is a wrapper around the Python callable that can be connected to a slot. </dt>
            <dt>Custom signals are defined as class attributes.</dt>
            <dt>Custom signals have the emit()method, which is used to emit the signal.</dt>
            <dt>Reference:</dt>
            <dd><a href="https://www.riverbankcomputing.com/static/Docs/PyQt6/signals_slots.html#defining-new-signals-with-pyqtsignal">Defining New Signals with pyqtSignal</a></dd>
            <dd><a href="https://www.riverbankcomputing.com/static/Docs/PyQt6/signals_slots.html#emit">emit</a></dd>
        </dl>
        <pre><code rel="Python" class="python">
            # create custom signal which will carry a string data type data:
            sig_submit = qtc.pyqtSignal(str)

            @qtc.pyqtSlot(bool)
            def onSubmit(self):
                self.sig_submit.emit(self.edit.text())
                self.close()
        </code></pre>
    </section>
    <section>
      <h3>Why using custom signals</h3>
      <dl class="fa" style="min-width:80vw">
        <dt>Custom signals help decouple components by allowing different widgets or objects to communicate without directly calling each other's methods</dt>
        <dt>Custom signals can be used to define specific events that aren't covered by the built-in PyQt signals, such as model changes, data updates, or complex state transitions</dt>
        <dt>They improve code modularity, as components can emit signals without needing to know which slot is handling them, reducing dependencies</dt>
        <dt>They provide a way to safely handle communication between different threads in a PyQt application</dt>
        <dt>Custom signals offer flexibility for complex applications, making it easier to manage and maintain large codebases by centralizing communication through signals</dt>
      </dl>
    </section>
</section>

<section data-min="50" class="main-section-title" id="SharingDataBetweenWidgets"><h1>Sharing data between widgets using custom signals and slots</h1></section>
<section class="sub-sections"><h2>Sharing data between widgets using custom signals and slots</h2>
    <section><h3>Common scenario</h3>
        <dl class="fa">
            <dt>Suppose you have a program that pops up a form window. When the user finishes filling the form and submits it, we need to get the entered data back to the main application class for processing.</dt>
            <dt>There are a few ways we could approach this:</dt>
            <dd>One is for the main application to watch for click events on the pop-up window's Submit button, then grab the data from its fields before destroying the dialog. But that approach requires the main form to know all about the pop-up dialog's widgets, and any refactoring of the pop-up would risk breaking code in the main application.</dd>
            <dd>Another option is to pass the main application a reference to the dialog's fields, but this approach still requires tight coupling between the two classes.</dd>
            <dd>The preferred approach is to use custom signals and slots to emit the form data when the user clicks Submit, allowing the main application to handle the data without needing to know the inner workings of the dialog.</dd>
        </dl>
    </section>
    <section><h3>Demo: tightly-coupled approach</h3>
        <p>Note that MainWindow must know DataEntryDialog's implementation</p>
        <pre><code rel="Python" class="python" style="min-height: 90vh;">
            import sys
            from PyQt6 import QtWidgets as qtw
            from PyQt6 import QtCore as qtc
            from PyQt6 import QtGui as qtg

            class DataEntryDialog(qtw.QDialog):
                def __init__(self , *args, **kwargs):
                    super().__init__(*args, **kwargs)
                    self.setWindowTitle('My Form')
                    self.setGeometry(500,400,200,100)

                    # ------------------------- create and atach widgets ------------------------- #
                    self.edit = qtw.QLineEdit()
                    self.btn_submit = qtw.QPushButton('Submit')

                    self.setLayout(qtw.QVBoxLayout())
                    self.layout().addWidget(self.edit)
                    self.layout().addWidget(self.btn_submit)

            class MainWindow(qtw.QWidget):
                def __init__(self , *args, **kwargs):
                    super().__init__(*args, **kwargs)
                    self.setWindowTitle('My App')
                    self.setGeometry(400,300,300,200)

                    # ------------------------- create and atach widgets ------------------------- #
                    self.label = qtw.QLabel('Initial Text')
                    self.btn_change = qtw.QPushButton('change text')

                    self.main_layout = qtw.QVBoxLayout()
                    self.main_layout.addWidget(self.label)
                    self.main_layout.addWidget(self.btn_change)
                    self.setLayout(self.main_layout)

                    # ---------------------------------- signals --------------------------------- #
                    self.btn_change.clicked.connect(self.onChangeClicked)

                    self.show()

                def onChangeClicked(self):
                    self.dialog = DataEntryDialog(self)
                    # tightly-coupled approach: we must know dialog's implementation
                    self.dialog.edit.setText(self.label.text())
                    self.dialog.btn_submit.clicked.connect(self.on_dialog_text_changed)

                    self.dialog.show()


                def on_dialog_text_changed(self):
                    self.label.setText(self.dialog.edit.text())
                    self.dialog.close()


            if __name__ == '__main__':
                app = qtw.QApplication(sys.argv);

                window = MainWindow()

                sys.exit(app.exec())
        </code></pre>
    </section>
    <section><h3>Demo: loosely-coupled approach</h3>
        <p>Note that MainWindow don't care about DataEntryDialog's implementation, it just pass and receive data</p>
        <pre><code rel="Python" class="python" style="min-height: 90vh;">
            import sys
            from PyQt6 import QtWidgets as qtw
            from PyQt6 import QtCore as qtc
            from PyQt6 import QtGui as qtg

            class DataEntryDialog(qtw.QDialog):
                data_submitted = qtc.pyqtSignal(str)

                def __init__(self , parent, msg):
                    super().__init__(parent)
                    self.setWindowTitle('My Form')
                    self.setGeometry(500,400,200,100)

                    # ------------------------- create and atach widgets ------------------------- #
                    self.edit = qtw.QLineEdit()
                    self.edit.setText(msg)
                    self.btn_submit = qtw.QPushButton('Submit')

                    self.setLayout(qtw.QVBoxLayout())
                    self.layout().addWidget(self.edit)
                    self.layout().addWidget(self.btn_submit)

                     # Connect the button click to emit the custom signal
                    self.btn_submit.clicked.connect(self.emit_data)

                def emit_data(self):
                    self.data_submitted.emit(self.edit.text())

            class MainWindow(qtw.QWidget):
                def __init__(self , *args, **kwargs):
                    super().__init__(*args, **kwargs)
                    self.setWindowTitle('My App')
                    self.setGeometry(400,300,300,200)

                    # ------------------------- create and atach widgets ------------------------- #
                    self.label = qtw.QLabel('Initial Text')
                    self.btn_change = qtw.QPushButton('change text')

                    self.main_layout = qtw.QVBoxLayout()
                    self.main_layout.addWidget(self.label)
                    self.main_layout.addWidget(self.btn_change)
                    self.setLayout(self.main_layout)

                    # ---------------------------------- signals --------------------------------- #
                    self.btn_change.clicked.connect(self.onChangeClicked)

                    self.show()

                def onChangeClicked(self):
                    self.dialog = DataEntryDialog(parent=self, msg=self.label.text())
                    # Connect the dialog's custom signal to update the label text in the main window
                    self.dialog.data_submitted.connect(self.on_dialog_text_changed)
                    self.dialog.show()


                def on_dialog_text_changed(self, msg):
                    self.label.setText(msg)
                    self.dialog.close()


            if __name__ == '__main__':
                app = qtw.QApplication(sys.argv);

                window = MainWindow()

                sys.exit(app.exec())
        </code></pre>
    </section>
</section>



<!-- <section data-min="5" class="main-section-title"><h1>Exercises</h1></section>
<section class="sub-sections"><h2>Exercises</h2>
    <section id="HW_Calculator"><h3>Task1: Calculator GUI</h3>
        <dl class="fa">
            <dt>Create the UI of a calculator, like the one shown in next image.</dt>
            <a href="./images/task_calculator_ui.png" title="click for bigger image"><img src="./images/task_calculator_ui.png" alt="./images/task_calculator_ui.png" style="min-height: 60vh;"></a>
            <dt>Use the Qt Designer and save the file as <code>calculator.ui</code></dt>
            <dt>Convert the generated <code> calculator.ui</code> file to python code, using the <code>pyuic5</code> tool</dt>
        </dl><br>

    </section>
</section> -->

<section class="disclaimer end-slide"></section>
<!--
########################################################
##################### SLIDES END   #####################
########################################################
-->
        </div>
    </div>
    <!-- Custom processing -->
    <script src="/PythonCourseNetIT-Slides/outfit/js/slides.js"></script>
    <!-- external scripts -->
    <script src="/PythonCourseNetIT-Slides/lib/reveal.js/lib/js/head.min.js"></script>
    <script src="/PythonCourseNetIT-Slides/lib/reveal.js/js/reveal.js"></script>
     <!-- init reveal -->
    <script>
        // Full list of configuration options available at:
        // https://github.com/hakimel/reveal.js#configuration
        var highlightjsTabSize = '  ';
        Reveal.initialize({
            controls: true,
            progress: true,
            slideNumber: 'c/t',
            keyboard: true,
            history: true,
            center: true,
            width: 1920,
            height: 1280,
            // Bounds for smallest/largest possible scale to apply to content
            // minScale: .5,
            maxScale: 1,
            // slide transition
            transition: 'concave', // none/fade/slide/convex/concave/zoom
            // Factor of the display size that should remain empty around the content
            margin: 0.1,
            // shift+left click to zoom in/out element
            zoomKey: 'ctrl',
            // theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
            // transition: Reveal.getQueryHash().transition || 'default'
            // Optional reveal.js plugins
            dependencies: [
                { src: '/PythonCourseNetIT-Slides/lib/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: '/PythonCourseNetIT-Slides/lib/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: '/PythonCourseNetIT-Slides/lib/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: '/PythonCourseNetIT-Slides/lib/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.configure({tabReplace: highlightjsTabSize}); hljs.initHighlightingOnLoad(); } },
                { src: '/PythonCourseNetIT-Slides/lib/reveal.js/plugin/zoom-js/zoom.js', async: true },
                { src: '/PythonCourseNetIT-Slides/lib/reveal.js/plugin/notes/notes.js', async: true }
            ]
        });
    </script>
</body>
</html>
